# -*- coding: utf-8 -*-
"""PCOS_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1paaUM2jhF2h6pNSAQPEGJ99h1DfZqxM-
"""

"""
PCOS Production System
CNN + Decision Tree + Ensemble + Conditional LIME
Uses 6-feature scaler matching decision tree training
"""

import numpy as np
import cv2
import os
import json
import joblib
import matplotlib.pyplot as plt
from tensorflow.keras.models import load_model
from lime import lime_image
from skimage.segmentation import mark_boundaries, quickshift
from skimage.feature import blob_log


class PCOSProductionSystem:

    def __init__(self, model_dir="models"):
        print("=" * 70)
        print("INITIALIZING PCOS PRODUCTION SYSTEM")
        print("=" * 70)

        # CNN
        self.cnn = load_model(os.path.join(model_dir, "final_model.keras"))
        print(" CNN loaded")

        # Decision Tree
        self.dt = joblib.load(os.path.join(model_dir, "decision_tree_model.pkl"))
        print(" Decision Tree loaded")

        # 6-feature scaler
        scaler_path = os.path.join(model_dir, "feature_scaler_6.pkl")
        if not os.path.exists(scaler_path):
            raise FileNotFoundError(
                "feature_scaler_6.pkl not found. "
            )
        self.scaler = joblib.load(scaler_path)
        print(" 6-feature scaler loaded")

        # Deployment config
        with open(os.path.join(model_dir, "deployment_config.json")) as f:
            cfg = json.load(f)
        self.alpha = cfg["ensemble_alpha"]
        self.threshold = cfg["decision_threshold"]

        # Feature order
        scaler_config_path = os.path.join(model_dir, "scaler_6_config.json")
        if os.path.exists(scaler_config_path):
            with open(scaler_config_path) as f:
                self.feature_order = json.load(f)["feature_names"]
            print(" Feature order loaded from scaler_6_config.json")
        else:
            self.feature_order = [
                'follicle_count',
                'follicle_density',
                'peripheral_distribution',
                'avg_follicle_size',
                'stromal_echogenicity',
                'ovarian_circularity'
            ]
            print(" scaler_6_config.json not found — using default feature order")

        # LIME
        self.lime = lime_image.LimeImageExplainer()

        print(f"\n  Alpha:     {self.alpha}")
        print(f"  Threshold: {self.threshold}")
        print(f"  Features:  {self.feature_order}")
        print("=" * 70)

    # -----------------------------
    # Feature extraction — top 6 only
    # -----------------------------
    def extract_features(self, image):
        """
        Extract the 6 features the decision tree was trained on.
        Also extracts ovarian_area_index for clinical reporting only.

        Args:
            image: RGB array (H, W, 3)
        Returns:
            dict with feature values
        """
        img = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        img = cv2.fastNlMeansDenoising(img, h=10)
        img = cv2.resize(img, (224, 224))

        features = {}

        # 1. Stromal echogenicity
        features['stromal_echogenicity'] = float(np.mean(img))

        # 2-4. Follicle features — blob_log with threshold=0.130 (same as training)
        img_normalized = img.astype(np.float32) / 255.0
        blobs = blob_log(
            img_normalized,
            min_sigma=3, max_sigma=8, num_sigma=8,
            threshold=0.130, overlap=0.3
        )

        follicle_count = len(blobs)
        features['follicle_count'] = float(follicle_count)
        features['follicle_density'] = float((follicle_count / (224 * 224)) * 10000)
        features['avg_follicle_size'] = (
            float(np.mean(blobs[:, 2] * np.sqrt(2))) if follicle_count > 0 else 0.0
        )

        # 5. Peripheral distribution
        h, w = img.shape
        center_mask = np.zeros_like(img, dtype=np.uint8)
        cv2.circle(center_mask, (w // 2, h // 2), min(h, w) // 4, 255, -1)

        center_b = float(np.mean(img[center_mask > 0])) if np.any(center_mask > 0) else 1.0
        peri_b = float(np.mean(img[center_mask == 0])) if np.any(center_mask == 0) else 1.0
        features['peripheral_distribution'] = peri_b / (center_b + 1e-6)

        # 6. Ovarian circularity  +  area (area used only for clinical reporting)
        blur = cv2.GaussianBlur(img, (5, 5), 0)
        binary = cv2.adaptiveThreshold(
            blur, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY_INV, 11, 2
        )
        kernel = np.ones((5, 5), np.uint8)
        binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
        contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if contours:
            largest = max(contours, key=cv2.contourArea)
            area = cv2.contourArea(largest)
            perimeter = cv2.arcLength(largest, True)
            features['ovarian_circularity'] = float(4 * np.pi * area / (perimeter ** 2 + 1e-6))
            features['ovarian_area_index'] = float(area)   # clinical report only
        else:
            features['ovarian_circularity'] = 0.0
            features['ovarian_area_index'] = 0.0

        return features

    # -----------------------------
    # Rule score
    # -----------------------------
    def rule_score(self, features):
        """Picks only the 6 features the scaler+tree expect, in the right order."""
        X = np.array([[features[f] for f in self.feature_order]])
        X_scaled = self.scaler.transform(X)
        return float(self.dt.predict_proba(X_scaled)[0, 1])

    # -----------------------------
    # CNN score
    # -----------------------------
    def cnn_score(self, image):
        img = cv2.resize(image, (224, 224)).astype(np.float32) / 255.0
        img = np.expand_dims(img, axis=0)          # (1, 224, 224, 3)
        return float(self.cnn.predict(img, verbose=0)[0, 0])

    # -----------------------------
    # LIME
    # -----------------------------
    def _lime_predict(self, images):
        if len(images.shape) == 3:
            images = np.expand_dims(images, 0)
        probs = self.cnn.predict(images, verbose=0).flatten()
        return np.column_stack([1 - probs, probs])

    def generate_lime(self, image, save_path="lime_result.png"):
        img = cv2.resize(image, (224, 224)).astype(np.float32) / 255.0

        explanation = self.lime.explain_instance(
            img, self._lime_predict,
            top_labels=2, num_samples=1000,
            segmentation_fn=lambda x: quickshift(x, kernel_size=4, max_dist=200, ratio=0.2)
        )

        temp, mask = explanation.get_image_and_mask(
            label=1, positive_only=True, num_features=10, hide_rest=False
        )

        plt.figure(figsize=(6, 6))
        plt.imshow(mark_boundaries(temp, mask))
        plt.axis("off")
        plt.title("LIME Explanation", fontsize=14, fontweight='bold')
        plt.tight_layout()
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.close()

        return save_path

    # -----------------------------
    # Clinical interpretation
    # -----------------------------
    def _interpret_clinical_features(self, features):
        findings = []

        count = features['follicle_count']
        if count >= 12:
            findings.append(f"High follicle count ({int(count)} follicles, threshold: ≥12)")
        elif count >= 8:
            findings.append(f"Elevated follicle count ({int(count)} follicles)")

        if features['follicle_density'] >= 5.0:
            findings.append(f"High follicular density ({features['follicle_density']:.1f})")

        if features['peripheral_distribution'] >= 1.1:
            findings.append("Peripheral follicle distribution (pearl necklace sign)")

        if features['stromal_echogenicity'] >= 100:
            findings.append(f"Increased stromal echogenicity ({features['stromal_echogenicity']:.1f})")

        if features['avg_follicle_size'] >= 3.0:
            findings.append(f"Multiple small follicles (avg size: {features['avg_follicle_size']:.1f}mm)")

        if features['ovarian_circularity'] < 0.7:
            findings.append(f"Irregular ovarian morphology (circularity: {features['ovarian_circularity']:.2f})")

        if features.get('ovarian_area_index', 0) >= 5000:
            findings.append(f"Enlarged ovarian area ({int(features['ovarian_area_index'])} pixels)")

        return findings

    # -----------------------------
    # Main entry point
    # -----------------------------
    def diagnose_from_array(self, image):
        """
        Args:
            image: RGB NumPy array (H, W, 3)
        Returns:
            dict — label, scores, lime path, clinical findings, raw features
        """
        features = self.extract_features(image)
        rule = self.rule_score(features)
        cnn = self.cnn_score(image)
        ensemble = self.alpha * cnn + (1 - self.alpha) * rule

        base = {
            "label": None,
            "ensemble_score": round(ensemble, 4),
            "cnn_probability": round(cnn, 4),
            "rule_score": round(rule, 4),
            "cnn_explanation": None,
            "clinical_features": [],
            "raw_features": features
        }

        if ensemble < self.threshold:
            base["label"] = "Normal"
            return base

        # PCOS — generate LIME explanation
        base["label"] = "PCOS"
        base["cnn_explanation"] = self.generate_lime(image)
        base["clinical_features"] = self._interpret_clinical_features(features)
        return base
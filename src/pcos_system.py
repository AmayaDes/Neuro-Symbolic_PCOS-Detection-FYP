# -*- coding: utf-8 -*-
"""PCOS_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1paaUM2jhF2h6pNSAQPEGJ99h1DfZqxM-
"""

import numpy as np
import cv2
import os
import json
import joblib
import matplotlib.pyplot as plt
from tensorflow.keras.models import load_model
from lime import lime_image
from skimage.segmentation import mark_boundaries, quickshift

class PCOSProductionSystem:
    """
    Full production system: CNN + Decision Tree + Ensemble + Conditional LIME
    """

    def __init__(self, model_dir="models"):
        # Load models
        self.cnn = load_model(os.path.join(model_dir, "final_model.keras"))
        self.dt = joblib.load(os.path.join(model_dir, "decision_tree_model.pkl"))
        self.scaler = joblib.load(os.path.join(model_dir, "feature_scaler.pkl"))

        # Load deployment config
        with open(os.path.join(model_dir, "deployment_config.json")) as f:
            cfg = json.load(f)

        self.alpha = cfg["ensemble_alpha"]
        self.threshold = cfg["decision_threshold"]

        # LIME
        self.lime = lime_image.LimeImageExplainer()

        print(" Production system loaded")
        print(f" alpha={self.alpha}, threshold={self.threshold}")

    # -----------------------------
    # Feature extraction
    # -----------------------------
    def extract_features(self, image):
        img = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        img = cv2.resize(img, (224,224))
        img = cv2.fastNlMeansDenoising(img, h=10)

        features = {}
        features["stromal_echogenicity"] = np.mean(img)

        img_norm = img / 255.0
        blobs = cv2.SimpleBlobDetector_create().detect(img_norm.astype(np.uint8))
        features["follicle_count"] = len(blobs)
        features["follicle_density"] = len(blobs) / (224*224) * 10000
        features["avg_follicle_size"] = np.mean([b.size for b in blobs]) if blobs else 0

        h,w = img.shape
        center = (w//2, h//2)
        mask = np.zeros_like(img)
        cv2.circle(mask, center, min(h,w)//4, 255, -1)

        center_b = np.mean(img[mask>0])
        peri_b = np.mean(img[mask==0])
        features["peripheral_distribution"] = peri_b/(center_b+1e-6)

        features["ovarian_circularity"] = 0.7  # simplified for production

        return features

    # -----------------------------
    # Rule model
    # -----------------------------
    def rule_score(self, features):
        order = [
            "stromal_echogenicity",
            "follicle_count",
            "follicle_density",
            "avg_follicle_size",
            "peripheral_distribution",
            "ovarian_circularity"
        ]
        X = np.array([[features[f] for f in order]])
        Xs = self.scaler.transform(X)
        return self.dt.predict_proba(Xs)[0,1]

    # -----------------------------
    # CNN
    # -----------------------------
    def cnn_score(self, image):
        img = cv2.resize(image, (224,224)) / 255.0
        img = np.expand_dims(img, axis=0)
        return float(self.cnn.predict(img, verbose=0)[0,0])

    # -----------------------------
    # LIME helpers
    # -----------------------------
    def lime_predict(self, images):
        if len(images.shape)==3:
            images = np.expand_dims(images,0)
        probs = self.cnn.predict(images, verbose=0).flatten()
        return np.column_stack([1-probs, probs])

    def generate_lime(self, image, save_path):
        img = cv2.resize(image, (224,224)) / 255.0

        explanation = self.lime.explain_instance(
            img,
            self.lime_predict,
            top_labels=2,
            num_samples=1000,
            segmentation_fn=lambda x: quickshift(x, kernel_size=4, max_dist=200, ratio=0.2)
        )

        temp, mask = explanation.get_image_and_mask(
            label=1,
            positive_only=True,
            num_features=10,
            hide_rest=False
        )

        plt.figure(figsize=(6,6))
        plt.imshow(mark_boundaries(temp, mask))
        plt.axis("off")
        plt.savefig(save_path, dpi=300)
        plt.close()

        return save_path

    # -----------------------------
    # MAIN ENTRY POINT
    # -----------------------------
    def diagnose_from_array(self, image):
        """
        image = NumPy array from upload
        """

        features = self.extract_features(image)
        rule = self.rule_score(features)
        cnn = self.cnn_score(image)

        ensemble = self.alpha*cnn + (1-self.alpha)*rule

        if ensemble < self.threshold:
            return {
                "label": "Normal",
                "cnn_probability": cnn,
                "ensemble_score": ensemble,
                "explanation_image": None,
                "clinical_features": []
            }

        lime_path = "lime_result.png"
        self.generate_lime(image, lime_path)

        return {
            "label": "PCOS",
            "cnn_probability": cnn,
            "ensemble_score": ensemble,
            "explanation_image": lime_path,
            "clinical_features": [
                f"Follicles: {features['follicle_count']}",
                f"Density: {features['follicle_density']:.2f}",
                f"Peripheral ratio: {features['peripheral_distribution']:.2f}"
            ]
        }